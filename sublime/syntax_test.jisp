;; SYNTAX TEST "jisp.sublime-syntax" ;;

This file is a sketch. A proper syntax test would include assertions for
expected scopes, which can be checked automatically by ST.

;; ;;
;; ;;;
;; ;;;;
;; ;;;;;
;; ;; ;; ;;

;;; ;;;
;;; ;;;;
;;; ;;;;;
;;; ;;;;;;
;;; ;;; ;; ;;

;; some_text ;;
;; some_text ;;;
;; some_text ;;;;
;; some_text ;; ;; ;;

;;; some_text ;;;
;;; some_text ;;;;
;;; some_text ;;;;;
;;; some_text ;;;;;;
;;; some_text ;;; ;; ;;

;;
some_text
;;

;;
some_text
;;;

;;
some_text
;;;;

;;
some_text
;;;;;

;;;
some_text
;;;

;;;
some_text
;;;;

;;;
some_text
;;;;;

;;;
some_text
;;;;;;

;;
some_text
some_text
;;

;;
some_text
some_text
;;;

;;
some_text
some_text
;;;;

;;
some_text
some_text
;;;;;

;;;
some_text
some_text
;;;

;;;
some_text
some_text
;;;;

;;;
some_text
some_text
;;;;;

;;;
some_text
some_text
;;;;;;

;; # Markdown heading 1 ;;

;;

# Markdown heading 1

## Markdown heading 2

### Markdown heading 3

Some text followed by # not Markdown heading.

;;

;; Invalid: ;;
.0
.1
.12
.123

;; Invalid: ;;
-.0
-.1
-.12
-.123

;; Invalid: ;;
.0ident
.1ident
.12ident
.123ident

;; Invalid: ;;
-.0ident
-.1ident
-.12ident
-.123ident

;; Invalid: ;;
0ident
1ident
12ident
123ident

0
1
12
123

-0
-1
-12
-123

0.1
1.2
12.3
123.4

-0.1
-1.2
-12.3
-123.4

;; Invalid: ;;
0nident
-0nident
1nident
-1nident
12nident
-12nident

;; Invalid: ;;
0.0n
-0.0n
0.1n
-0.1n
0.12n
-0.12n
12.34n
-12.34n

0n
-0n
1n
-1n
12n
-12n

``
""

` `
" "

` ``
" ""

` ```
" """

` ````
" """"

` `""
" "``

` ` ``
" " ""

` ` ` `
" " " "

`one`
"one"

`\"`
"\""

`\"``
"\"""

`\r\n\t\v\\\"`
"\r\n\t\v\\\""

`\r\n\t\v\\\"``
"\r\n\t\v\\\"""

` \r \n \t \v \\ \" `
" \r \n \t \v \\ \" "

` \r \n \t \v \\ \" ``
" \r \n \t \v \\ \" ""

``` ```
""" """

``` ````
""" """"

``` ```""
""" """``

```one```
"""one"""

```one````
"""one""""

```one```""
"""one"""``

```
one
```

```
one
````

```
one
`````

```
one
``````

```
one
``` ``

```
one
```""

```
one
``` ""

"""
one
"""

"""
one
""""

"""
one
"""""

"""
one
""""""

"""
one
"""``

"""
one
""" ``

```
one
two
three
```

"""
one
two
three
"""

```
one
`
two
`
three
```

"""
one
"
two
"
three
"""

;; Invalid ;;
``.
``..
``...
```
```.
```
```..
```
```...

;; Invalid ;;
"".
""..
""...
"""
""".
"""
"""..
"""
"""...

~ ! @ # % ^ & * : < > ? / \ | = + -
~~ !! @@ ## %% ^^ && ** :: << >> ?? // \\ || == ++ --
~~~ !!! @@@ ### %%% ^^^ &&& *** ::: <<< >>> ??? /// \\\ ||| === +++ ---
~-+ !~- @!~ #@! %#@ ^%# &^% *&^ :*& <:* ><: ?>< /?> \/? |\/ =|\ +=| -+=

;; Invalid: ;;
~123
!123
@123
#123
%123
^123
&123
*123
:123
<123
>123
?123
/123
\123
|123
=123
+123

;; Invalid: ;;
--123
+-123
-+123
++123

;; Invalid: ;;
123-
123~
123!
123@
123#
123%
123^
123&
123*
123:
123<
123>
123?
123/
123\
123|
123=
123+
123-

;; Invalid: ;;
~`str`
!`str`
@`str`
#`str`
%`str`
^`str`
&`str`
*`str`
:`str`
<`str`
>`str`
?`str`
/`str`
\`str`
|`str`
=`str`
+`str`

;; Valid: ;;
~ `str`
! `str`
@ `str`
# `str`
% `str`
^ `str`
& `str`
* `str`
: `str`
< `str`
> `str`
? `str`
/ `str`
\ `str`
| `str`
= `str`
+ `str`

;; Invalid: ;;
`str`-
`str`~
`str`!
`str`@
`str`#
`str`%
`str`^
`str`&
`str`*
`str`:
`str`<
`str`>
`str`?
`str`/
`str`\
`str`|
`str`=
`str`+
`str`-

;; Valid: ;;
`str` -
`str` ~
`str` !
`str` @
`str` #
`str` %
`str` ^
`str` &
`str` *
`str` :
`str` <
`str` >
`str` ?
`str` /
`str` \
`str` |
`str` =
`str` +
`str` -

;; Invalid: ;;
~ident
!ident
@ident
#ident
%ident
^ident
&ident
*ident
:ident
<ident
>ident
?ident
/ident
\ident
|ident
=ident
+ident

;; Valid: ;;
~ ident
! ident
@ ident
# ident
% ident
^ ident
& ident
* ident
: ident
< ident
> ident
? ident
/ ident
\ ident
| ident
= ident
+ ident

;; Invalid: ;;
ident-
ident~
ident!
ident@
ident#
ident%
ident^
ident&
ident*
ident:
ident<
ident>
ident?
ident/
ident\
ident|
ident=
ident+
ident-

;; Valid: ;;
ident -
ident ~
ident !
ident @
ident #
ident %
ident ^
ident &
ident *
ident :
ident <
ident >
ident ?
ident /
ident \
ident |
ident =
ident +
ident -

one
one.two
one .two
one.two.three
one .two.three
one.two .three
one .two .three

one
.two
.three

[].one
[].one.two
[].one.two.three

[one] two three
[one two] three
[one two three]

[.one].two
[.one].two.three
[.one.two].three
[.one.two.three]

[.one two].three
[.one.two three]

    void     undefined     null     false     true     NaN     Infinity
pre.void pre.undefined pre.null pre.false pre.true pre.NaN pre.Infinity

use
pre.use
[use]
[pre.use]
[use ident]
[pre.use ident]
[use ident ident]
[pre.use ident ident]
[use *]
[pre.use *]
[use ident *]
[pre.use ident *]
[use `addr`]
[pre.use `addr`]
[use "addr"]
[pre.use "addr"]
[use `addr` name]
[pre.use `addr` name]
[use "addr" name]
[pre.use "addr" name]
[use `addr` *]
[pre.use `addr` *]
[use "addr" *]
[pre.use "addr" *]

const
pre.const
[ident const ident]
[ident pre.const ident]
[ident const.variant ident]
[ident pre.const.variant ident]
[const]
[pre.const]
[const     name]
[pre.const name]
[const     name val]
[pre.const name val]
[const.variant]
[pre.const.variant]
[const.variant     name]
[pre.const.variant name]
[const.variant     name val]
[pre.const.variant name val]

;; Name declaration should support list deconstruction. ;;
[const [one] val]
[const [one two] val]
[const [one [two]] val]
[const [one [two & [three]]] val]

func
pre.func
[ident func ident]
[ident pre.func ident]
[ident func.variant ident]
[ident pre.func.variant ident]
[func]
[pre.func]
[func.variant]
[pre.func.variant]
[func             name]
[pre.func         name]
[func.variant     name]
[pre.func.variant name]
[func             name []]
[pre.func         name []]
[func.variant     name []]
[pre.func.variant name []]
[func             name [param]]
[pre.func         name [param]]
[func.variant     name [param]]
[pre.func.variant name [param]]
[func             name [param param]]
[pre.func         name [param param]]
[func.variant     name [param param]]
[pre.func.variant name [param param]]
[func             name [param param &]]
[pre.func         name [param param &]]
[func.variant     name [param param &]]
[pre.func.variant name [param param &]]
[func             name [param param & param]]
[pre.func         name [param param & param]]
[func.variant     name [param param & param]]
[pre.func.variant name [param param & param]]
[func             name [param param] body]
[pre.func         name [param param] body]
[func.variant     name [param param] body]
[pre.func.variant name [param param] body]
[func             name [param param &] body]
[pre.func         name [param param &] body]
[func.variant     name [param param &] body]
[pre.func.variant name [param param &] body]
[func             name [param param & param] body]
[pre.func         name [param param & param] body]
[func.variant     name [param param & param] body]
[pre.func.variant name [param param & param] body]
[func             name [param] [body] [body] [body] body]
[func.variant     name [param] [body] [body] [body] body]
[pre.func         name [param] [body] [body] [body] body]
[pre.func.variant name [param] [body] [body] [body] body]

;; Parameter lists should support list deconstruction. ;;
[func name [one two] body]
[func name [one [two]] body]
[func name [[one] two] body]
[func name [[one two]] body]
[func name [one [two] three] body]
[func name [one [two] three [four]] body]
[func name [one & [two] three [four & five]] body]

;;
Only unqualified identifiers in the parameter list should be scoped as
parameters. Everything else should be scoped as in root scope.
;;
[func name [one two.three `str` !@#.four `str` five.!@# six] body]

class
pre.class
[ident class ident]
[ident pre.class ident]
[ident class.variant ident]
[ident pre.class.variant ident]
[class]
[pre.class]
[class name]
[pre.class name]

[class name
  [meth                name]
  [static.meth         name]
  [meth.variant        name]
  [static.meth.variant name]

  [.meth                name]
  [.static.meth         name]
  [.meth.variant        name]
  [.static.meth.variant name]

  [meth                name []]
  [static.meth         name []]
  [meth.variant        name []]
  [static.meth.variant name []]

  [.meth                name []]
  [.static.meth         name []]
  [.meth.variant        name []]
  [.static.meth.variant name []]

  [meth                name [param]]
  [static.meth         name [param]]
  [meth.variant        name [param]]
  [static.meth.variant name [param]]

  [.meth                name [param]]
  [.static.meth         name [param]]
  [.meth.variant        name [param]]
  [.static.meth.variant name [param]]

  [meth                name [param param]]
  [static.meth         name [param param]]
  [meth.variant        name [param param]]
  [static.meth.variant name [param param]]

  [.meth                name [param param]]
  [.static.meth         name [param param]]
  [.meth.variant        name [param param]]
  [.static.meth.variant name [param param]]
]

[fn]
[pre.fn]
[fn.async]
[pre.fn.async]
[fn $0]
[pre.fn $0]
[fn.async $0]
[pre.fn.async $0]
[fn $0 $1]
[pre.fn $0 $1]
[fn.async $0 $1]
[pre.fn.async $0 $1]

;;
Unqualified identifiers in the form `^[$]\d+$` should be scoped as parameters.
When such identifiers are qualified, no special treatment should be given.
;;
$0 $1 $2 ... $128
pre.$0 pre.$1 pre.$2 ... pre.$128

;; Property access should be scoped normally. ;;
$0.field
$0.field.field
$0.!@#
$0.!@#.%^&
$0.field.%^&
$0.!@#.field
