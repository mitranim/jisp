%YAML 1.2
---
version: 2
scope: source.jisp
file_extensions: [jisp]

variables:
  comment_delim: ;
  comment_fence: '({{comment_delim}}{2,})(?!{{comment_delim}})'

  string_backtick_delim: '`'
  string_backtick_fence: '({{string_backtick_delim}}+)(?!{{string_backtick_delim}})'

  string_double_delim: '"'
  string_double_fence: '({{string_double_delim}}+)(?!{{string_double_delim}})'

  char_escape: \\(?:.|\n)
  # SYNC[accessor].
  accessor: \.
  space: \s*
  eol: (?:\n|$)

  # int_bin: '(?:[0-1][0-1_]*)'
  # int_oct: '(?:[0-7][0-7_]*)'
  int_dec: '(?:[0-9][0-9_]*)'
  # int_hex: '(?:[0-9a-f][0-9a-f_]*)'

  # SYNC[ident_oper].
  operator_chars: '\~\!\@\#\%\^\&\*\:\<\>\?\/\\\|\=\+\-'
  operator: '[{{operator_chars}}]+'

  ident_begin_chars: '[:alpha:]_$'
  ident_chars: '[:alnum:]_$'
  entity_chars: '{{ident_chars}}{{operator_chars}}'
  ident_break_begin: (?<![{{ident_chars}}])
  ident_break_end: (?![{{ident_chars}}])
  ident: '{{ident_break_begin}}[{{ident_begin_chars}}][{{ident_chars}}]*{{ident_break_end}}'

contexts:
  prototype:
    - include: comment-match

  # Should match `Tokenizer`.
  main:
    - include: delim-match
    - include: number-match
    - include: string-match
    - include: operator-match
    - include: ident-match
    - include: punct-match

  comment-match:
    - include: comment-fenced-match

  comment-fenced-match:
    - match: '{{comment_fence}}'
      scope: comment.block.jisp punctuation.definition.comment.begin.jisp
      push: [req-delim-pop, comment-block-meta, comment-fenced-pop]

  comment-fenced-pop:
    - meta_include_prototype: false
    - match: \1
      scope: comment.block.jisp punctuation.definition.comment.end.jisp
      pop: 1
    - include: comment-markup

  comment-block-meta:
    - meta_content_scope: comment.block.jisp
    - include: now-pop

  comment-markup:
    - include: comment-heading-match

  # Known limitation: this doesn't match headings placed between comment
  # delimiters on a single line.
  comment-heading-match:
    - match: '^{{space}}((#+)\s+\S.*)(?:{{eol}})'
      captures:
        1: markup.heading.jisp
        2: punctuation.definition.heading.begin.jisp

  delim-match:
    - include: braces-match
    - include: brackets-match
    - include: parens-match

  braces-match:
    - match: \{
      scope: punctuation.section.braces.begin.jisp
      push: [braces-pop, list-head-pop]
    - match: \}
      scope: punctuation.section.braces.end.jisp invalid.illegal.jisp

  braces-pop:
    - include: brace-pop
    - include: main

  brace-pop:
    - meta_scope: meta.block.jisp meta.braces.jisp
    - match: \}
      scope: punctuation.section.braces.end.jisp
      pop: 1

  brackets-match:
    - match: \[
      scope: punctuation.section.brackets.begin.jisp
      push: [brackets-pop, list-head-pop]
    - match: \]
      scope: punctuation.section.brackets.end.jisp invalid.illegal.jisp

  brackets-pop:
    - include: bracket-pop
    - include: main

  bracket-pop:
    - meta_scope: meta.block.jisp meta.brackets.jisp
    - match: \]
      scope: punctuation.section.brackets.end.jisp
      pop: 1

  parens-match:
    - match: \(
      scope: punctuation.section.parens.begin.jisp
      push: [parens-pop, list-head-pop]
    - match: \)
      scope: punctuation.section.parens.end.jisp invalid.illegal.jisp

  parens-pop:
    - include: paren-pop
    - include: main

  paren-pop:
    - meta_scope: meta.block.jisp meta.parens.jisp
    - match: \)
      scope: punctuation.section.parens.end.jisp
      pop: 1

  punct-match:
    - include: accessor-match

  accessor-match:
    - match: '{{accessor}}'
      scope: punctuation.accessor.dot.jisp

  number-match:
    - include: number-bigint-match
    - include: number-dec-match

  number-bigint-match:
    - match: '(-)?{{int_dec}}(n)'
      scope: constant.numeric.jisp
      captures:
        1: keyword.operator.arithmetic.jisp
        2: constant.numeric.suffix.jisp
      push: req-delim-pop

  # Must match `Num.regex`.
  number-dec-match:
    - include: number-dec-frac-match
    - include: number-dec-int-match

  number-dec-frac-match:
    - match: '(-)?{{int_dec}}(\.){{int_dec}}'
      scope: constant.numeric.jisp
      captures:
        1: keyword.operator.arithmetic.jisp
        2: punctuation.separator.decimal.jisp
      push: req-delim-pop

  number-dec-int-match:
    - match: '(-)?{{int_dec}}'
      scope: constant.numeric.jisp
      captures:
        1: keyword.operator.arithmetic.jisp
      push: req-delim-pop

  string-match:
    - include: string-backtick-match
    - include: string-double-match

  string-backtick-match:
    - include: string-backtick-empty-match
    - include: string-backtick-fenced-match

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  string-backtick-empty-match:
    - match: '({{string_backtick_delim}})({{string_backtick_delim}})(?!{{string_backtick_delim}})'
      scope: string.quoted.other.jisp
      captures:
        1: punctuation.definition.string.begin.jisp
        2: punctuation.definition.string.end.jisp

  string-backtick-fenced-match:
    - match: '{{string_backtick_fence}}'
      scope: string.quoted.other.jisp punctuation.definition.string.begin.jisp
      push: [req-delim-pop, string-backtick-meta, string-backtick-pop]

  string-backtick-pop:
    - meta_include_prototype: false
    - match: \1
      scope: punctuation.definition.string.end.jisp
      pop: 1

  string-backtick-meta:
    - meta_content_scope: string.quoted.other.jisp
    - include: now-pop

  string-double-match:
    - include: string-double-empty-match
    - include: string-double-fenced-match

  # This special case matches two quotes with no other content, treating it as
  # an empty string. This means we won't be treating it as an opening fence.
  string-double-empty-match:
    - match: '({{string_double_delim}})({{string_double_delim}})(?!{{string_double_delim}})'
      scope: string.quoted.other.jisp
      captures:
        1: punctuation.definition.string.begin.jisp
        2: punctuation.definition.string.end.jisp

  string-double-fenced-match:
    - match: '{{string_double_fence}}'
      scope: string.quoted.double.jisp punctuation.definition.string.begin.jisp
      push: [req-delim-pop, string-double-meta, string-double-pop]

  string-double-pop:
    - meta_include_prototype: false
    - include: string-escape-match
    - match: \1
      scope: punctuation.definition.string.end.jisp
      pop: 1

  string-double-meta:
    - meta_content_scope: string.quoted.double.jisp
    - include: now-pop

  string-escape-match:
    - match: '{{char_escape}}'
      scope: constant.character.escape.jisp

  operator-match:
    - match: '{{operator}}'
      scope: keyword.operator.jisp
      push: req-delim-after-sym-pop

  ident-match:
    - include: ident-constant-match
    - include: ident-unqual-match

  # Questionable special case, provided for syntactical consistency with other
  # languages. Unlike most languages, Jisp does not have any keywords or
  # reserved words, and these "constants" are regular identifiers exported by
  # prelude, which is completely optional. They can be used unqualified or
  # qualified, and more importantly, they can be renamed or replaced. There is
  # really totally nothing special about them. We may reconsider this.
  ident-constant-match:
    - match: '{{ident_break_begin}}(?:nil|null|no|ok|nan|inf){{ident_break_end}}'
      scope: constant.language.jisp
      push: req-delim-after-sym-pop

  # Naming refers to `IdentUnqual`.
  ident-unqual-match:
    - match: '{{ident}}'
      scope: variable.other.jisp
      push: req-delim-after-sym-pop

  # Naming refers to `IdentAccess`.
  ident-access-pop-multi:
    - match: '({{accessor}}){{space}}({{ident}})'
      captures:
        1: punctuation.accessor.dot.jisp
        2: variable.other.jisp
    - include: nonblank-pop

  list-head-pop:
    - include: accessor-match
    - include: call-known-pop-opt
    - include: call-unknown-pop-opt
    - include: ident-unqual-match
    - include: nonblank-pop

  call-unknown-pop-opt:
    - match: '{{ident}}(?!{{accessor}})'
      scope: variable.function.jisp
      set: req-delim-after-sym-pop

  call-known-pop-opt:
    - include: call-use-pop
    - include: call-import-pop
    - include: call-const-pop
    - include: call-let-pop
    - include: call-func-pop
    - include: call-meth-pop
    - include: call-class-pop

  call-use-pop:
    - match: '{{ident_break_begin}}use{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [import-addr-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  call-import-pop:
    - match: '{{ident_break_begin}}import{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [import-addr-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  # Semi-placeholder. Instead of special-case string support, we should pop an
  # arbitrary expression here.
  import-addr-pop:
    - match: '({{string_backtick_delim}})[^{{string_backtick_delim}}]*({{string_backtick_delim}})(?!{{string_backtick_delim}})'
      scope: string.quoted.other.jisp
      captures:
        1: punctuation.definition.string.begin.jisp
        2: punctuation.definition.string.end.jisp
      set: [import-decl-pop, req-delim-pop]

    - match: '({{string_double_delim}})[^{{string_double_delim}}]*({{string_double_delim}})(?!{{string_double_delim}})'
      scope: string.quoted.double.jisp
      captures:
        1: punctuation.definition.string.begin.jisp
        2: punctuation.definition.string.end.jisp
      set: [import-decl-pop, req-delim-pop]

    - include: nonblank-pop

  import-decl-pop:
    - match: '{{ident}}'
      scope: meta.binding.name.jisp variable.other.jisp
      set: req-delim-after-sym-pop
    - include: nonblank-pop

  call-const-pop:
    - match: '{{ident_break_begin}}const{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [declare-variable-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  call-let-pop:
    - match: '{{ident_break_begin}}let{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [declare-variable-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  declare-variable-pop:
    - match: '{{ident}}'
      scope: meta.binding.name.jisp entity.name.jisp
      set: req-delim-after-sym-pop
    - include: nonblank-pop

  call-func-pop:
    - match: '{{ident_break_begin}}func{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [func-name-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  func-name-pop:
    - match: '{{ident}}'
      scope: entity.name.function.jisp
      set: [params-outer-pop, req-delim-after-sym-pop]
    - include: nonblank-pop

  call-meth-pop:
    - match: '{{ident_break_begin}}meth{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [func-name-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  params-outer-pop:
    - match: \{
      scope: punctuation.section.braces.begin.jisp
      set: params-brace-pop
    - match: \[
      scope: punctuation.section.brackets.begin.jisp
      set: params-bracket-pop
    - match: \(
      scope: punctuation.section.parens.begin.jisp
      set: params-paren-pop
    - include: nonblank-pop

  params-brace-pop:
    - include: brace-pop
    - include: params-inner-match

  params-bracket-pop:
    - include: bracket-pop
    - include: params-inner-match

  params-paren-pop:
    - include: paren-pop
    - include: params-inner-match

  params-inner-match:
    - match: '{{ident}}(?!{{accessor}})'
      scope: variable.parameter.jisp
      push: req-delim-after-sym-pop
    - include: main

  call-class-pop:
    - match: '{{ident_break_begin}}class{{ident_break_end}}'
      scope: keyword.declaration.jisp
      set: [class-name-pop, ident-access-pop-multi, req-delim-after-sym-pop]

  class-name-pop:
    - match: '{{ident}}'
      scope: entity.name.class.jisp
      set: req-delim-after-sym-pop
    - include: nonblank-pop

  req-delim-after-sym-pop:
    - match: '[^.\s{}\[\]()]+'
      scope: invalid.illegal.jisp
    - include: now-pop

  req-delim-pop:
    - match: '[^\s{}\[\]()]+'
      scope: invalid.illegal.jisp
    - include: now-pop

  nonblank-pop:
    - match: (?=\S)
      pop: 1

  now-pop:
    - match: ''
      pop: 1
