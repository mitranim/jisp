[use `jisp:prelude.mjs` *]
[use `jisp:prelude.mjs` p]
[use `jisp:prelude.mjs` pre]

; Generates a syntactically valid call that panics at runtime.
[nil no ok]

[const someVal 10]

; OK.
someVal

; Compile error.
; [func someFunc0 [] someArg]

; OK.
[func someFunc1 [someArg] someArg]

; Must generate a runtime call without "new".
[someFunc1 10 20 30]

; OK.
[func someFunc2 [] someVal]

[callSyntax `list run new val` someFunc2]

; Must generate a runtime call with "new".
[someFunc2 10 20 30]

[pre.global.console.log `logging0`]

[global.console.log `logging1`]

; "global" must be predefined.
[const g global]

; FIXME implement.
; FIXME exclude from compiled code, unless used by non-macros.
[func astMacro []
  ; Shadowing must work.
  [const g global]
  [g.console.log `executing AST macro`]

  ; FIXME implement.
  ; FIXME compile error for unknown identifier "one" and others.
  ; [quote [one two three]]
]

; [setCallSyntax astMacro "macroAst"]
; [callSyntax `LMCA` astMacro]
[callSyntax `list macro call ast` astMacro]

; Compile error.
; astMacro

[astMacro 10 20 30]

[func valMacro []
  ; Shadowing must work.
  [const g global]
  [g.console.log `executing val macro`]
  [g.Array.of
    10
    [g.Object.fromEntries
      [g.Array.of
        [g.Array.of `one` 20]
        [g.Array.of `ðŸ™‚ðŸ˜›ðŸ˜ž` 30]
      ]
    ]
  ]
]

; TODO consider: get "Decl" and call its method.
; [setCallSyntax valMacro `macroAst`]
; [callSyntax `LMCV` valMacro]
[callSyntax `list macro call val` valMacro]

; Compile error.
; valMacro

[valMacro 10 20 30]
