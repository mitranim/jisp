; Utils for other modules

; Got bloated, todo refactor

; # For compiler

(= exports.symbolWhitelist (= symbolWhitelist `(
; List of non-\w 'words' for lexer to consider valid atoms
   ; arithmetic
   "+" "-" "*" "/" "%" "++" "--"
   ; logical
   "?" "?!" "==" "===" "!=" "!==" "&&" "||" "!" "!!"
   ; comparison
   ">" "<" ">=" "<="
   ; bitwise
   "&" "|" "^" "<<" ">>" ">>>" "~"
   ; assignment
   "=" "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" ">>>=" "&=" "^=" "|=")))

(= exports.keywords (= keywords `(
  "return" "break" "continue" "throw" "delete"
)))

(= exports.kwtest (def kwtest str (do
   (= re (RegExp (do (for kw keywords
                          (+ "^" kw))
                     (.join "|"))))
   (re.test str))))
   ; (or (/^return/.test str)
   ;     (/^break/.test str)
   ;     (/^continue/.test str))))

(= exports.specialValues (= specialValues `(
  "undefined" "null" "true" "false" "yes" "no" "Infinity" "NaN"
)))

(= exports.isSpecialValueStr (def isSpecialValue str
  (in str specialValues)))

(= exports.isSpecialValue (def isSpecialValue form
  (or (isa form "undefined")
      (is form null)
      (and (isa form "number") (isNaN form))
      (is form Infinity)
      (isa form "boolean"))))

; Composite types

(= exports.isAtom (def isAtom form
   (or (is form undefined null)
           (/^\/[^\s\/]+\/[\w]*$/.test form)
           (isa form "number" "string" "boolean"))))

(= exports.isAtomString (def isAtomString form
   (and (not (isSpecialValue form))
        (or (isNum form)
            (isRegex form)
            (isIdentifier form)
            (isString form)
            (in form symbolWhitelist)
            (/^#[\d]+$/.test form)  ; #n notation
            (/^#$/.test form)))))   ; # notation

(= exports.isList (def isList form
   (Array.isArray form)))

(= exports.isHash (def isHash form
   (and (not (isAtom form))
        (not (isList form))
        (not (isa form "function")))))

(= exports.isBlankObject (def isBlankObject form
   (try (is (get (Object.keys form) length) 0)
        false)))

(= exports.isKey (def isKey form
   (and (isAtom form) (or (isString form)
                          (isIdentifier form)
                          (isNum form)))))

; Simple types

(= exports.isVarName (def isVarName form
; matches pure variable names without property notation
   (and (isAtom form) (/^[$_A-Za-z]{1}$|^[$_A-Za-z]+[$_\w]*(?:[$_\w](?!\.))+$/.test form))))

(= exports.isIdentifier (def isIdentifier form
; matches any identifier, including with .dot and [bracket] and ["string bracket"] notation, unless it has an expression in brackets
   (and (isAtom form)
        (/^[$_A-Za-z]{1}[$_\w]*((\.[$_A-Za-z]{1}[$_\w]*)|(\[[$_.\w\[\]]+\])|(\['.*'\])|(\[".*"\]))*$/.test form))))

(= exports.isString (def isString form
   (and (isAtom form) (/^".*"$|^'.*'$/.test form))))

(= exports.isRegex (def isRegex form
; passes regexes and regexes+stuff
   (and (isAtom form) (/^\/[^\s]+\/[\w]*[^\s)]*/.test form))))

(= exports.isNum (def isNum form
   (and (isAtom form) (isa (typify form) "number"))))

(= exports.isPrimitive (def isPrimitive form
   (or (isRegex form)
       (isNum form)
       (is form undefined null yes no))))

(= exports.isArgHash (def isArgHash form
   (and (isAtom form) (/^#[\d]+$/.test form))))

(= exports.isArgsHash (def isArgsHash form
   (and (isAtom form) (/^#$/.test form))))

(= exports.isArgHashNotation (def isArgHashNotation form
   (or (isArgHash form)
       (isArgsHash form))))

; Property syntax â€” dot and bracket notation

(= exports.isDotName (def isDotName form
   (and (isAtom form) (/^\.[$_A-Za-z]{1}$|^\.[$_A-Za-z]+[$_.\w]*(?:[$_\w](?!\.))+$/.test form))))

(= exports.isBracketName (def isBracketName form
   (and (isAtom form) (/^\[[$_A-Za-z]{1}\]$|^\[[$_A-Za-z]+[$_.\w]*(?:[$_\w](?!\.))+\]$/.test form))))

(= exports.isBracketString (def isBracketString form
   (and (isAtom form) (/^\[".*"\]$|^\['.*'\]$/.test form))))

(= exports.isPropSyntax (def isPropSyntax form
   (and (isAtom form) (or (isDotName form)
                          (isBracketName form)
                          (isBracketString form)))))

; Other

(= exports.typify (def typify form
   (if (not (isAtom form))
       (throw (Error (+ "expecting atom, got " (pr form))))
       (elif (isBlankObject form) form)
       (elif (isa form "undefined") undefined)
       (elif (is form "null") null)
       (elif (is form "true" "yes") true)
       (elif (is form "false" "no") false)
       (elif (not (isNaN (Number form))) (Number form))
       (elif (isRegex form) form)
       (elif (isa form "string") form)
       (throw (Error (+ "syntax error: unrecognised type of " (pr form)))))))

(= exports.assertForm (def assertForm form (min 0) (max Infinity) first
   (if (not (isList form))
      (throw (Error (+ "expecting list, got " form)))
      (elif (not (and (>= form.length min) (<= form.length max)))
            (throw (Error (+ "expecting between " min " and " max " arguments, got " form.length ": " (pr form)))))
      (elif (and (? first) (isnt form[0] first))
            (throw (Error (+ "expecting " (pr first) " as first element, got " (pr form[0])))))
      form)))

(= exports.assertExp (def assertExp exp test (expect "valid expression")
     (if (test exp) true
         (throw (Error (+ "expecting " (pr expect) ", got " (pr exp)))))))

; # For rendering

; Pretty-print
; Turns data objects into pretty-looking strings, with proper [ ] and { } delimiters for arrays and hash tables
(= exports.pr (def pr item
     (if (isAtom item)
         (do (+ "" item)
             (.replace /;$/ ""))  ; remove trailing semicolon, if any
         (elif (isHash item)
           (do (= res "")
               (over val key item
                     (+= res (+ key ": " (pr val) ", ")))
               (+ "{ " (res.slice 0 -2) " }")))
         (elif (isList item)
               (do (= res "")
                   (for val item
                        (+= res (+ (pr val) ", ")))
                   (+ "[ " (res.slice 0 -2) " ]")))
         ; (throw (Error (+ "unrecognised kind of data object: " item))))))
         (+ "" item))))

; Turns an array into a string without [ ] delimiters: [1, 2, 3] -> 1, 2, 3
; For printing-spreading
(= exports.spr (def spr item
     (if (isList item)
         (do (= res "")
             (for val item
                  (+= res (+ (pr val) ", ")))
             (res.slice 0 (- res.length 2)))
         (throw (Error "can only print-spread lists")))))

; Turns an array of strings into one rendered string
(= exports.render (def render buffer
  (do (for exp i buffer
           ; `undefined`, "", and `() don't render at all
           (if (or (and (isList exp) (is exp.length 0))
                   (isa exp "undefined")
                   (is exp ""))
               (= buffer[i] undefined)  ; won't be displayed after `join`ing
               (do (if (isa exp "string") (= exp (exp.trim)))
                   (= res (pr exp))
                   ; hash tables and lambdas need extra parens when on their own line
                   (if (or (isHash exp)
                           (/^function\s*\(/.test res))
                       (= res (+ "(" res ")")))
                   ; add semicolons to forms that need them
                   (if (not (/:$|\}$|;$/.test (res.slice -1)))
                       (+= res ";"))
                   (= buffer[i] res))))
      (buffer.join " ")
      (.trim))))

; Removes all pairs of parentheses around a string
; MUST NOT be applied to strings compiled from multiple expressions, only a SINGLE expression
(= exports.deParenthesise (def deParenthesise str
  (if (isa str "string")
      (while (and (str.match /^\({1}/)
                  (str.match /\){1}$/))
        (= str (do str
                   (.replace /^\({1}/ "")
                   (.replace /\){1}$/ "")))
        str)
      str)))

; Removes extra pairs of parentheses around a string
; MUST NOT be applied to strings compiled from multiple expressions, only a SINGLE expression
(= exports.dePairParenthesise (def dePairParenthesise str
  (if (isa str "string")
      (while (and (str.match /^\({2}/)
                  (str.match /\){2}$/))
        (= str (do str
                   (.replace /^\({2}/ "(")
                   (.replace /\){2}$/ ")")))
        str)
      str)))

; # For command line
; Mostly copied from CoffeeScript source

; Merges objects, returning fresh copy with attributes from both sides
(= exports.merge (def merge options overrides
   (extend (extend (:) options) overrides)))

; Extend source object with properties of another object (shallow copy)
(= exports.extend (def extend object properties
   (do (over val key properties
             (= object[key] val))
       object)))

; Return filename without extension
(= exports.baseFileName (def baseFileName file (stripExt no) (useWinPathSep no)
   (do (= pathSep (if useWinPathSep /\\|\// /\//)
          parts   (file.split pathSep)
          file    (last parts))
       (if (not (and stripExt (>= (file.indexOf ".") 0)))
           (return file))
       (= parts (file.split "."))
       (parts.pop)
       (if (and (is (last parts) "jisp")
                (> parts.length 1))
           (parts.pop))
       (parts.join "."))))

; Repeat string `n` times
(= exports.repeat (def repeat str n
  (do (= res "")
      (while (> n 0)
             (do (if (& n 1) (+= res str))
                 (>>>= n 1)
                 (+= str str)))
      res)))

(= exports.isJisp (def isJisp file
  (/\.jisp$/.test file)))
